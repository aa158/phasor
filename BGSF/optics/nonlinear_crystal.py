# -*- coding: utf-8 -*-
"""
"""
from __future__ import (division, print_function)
import numpy as np

import declarative

from . import ports
from . import bases

from ..system.matrix_injections import (
    FactorCouplingBase,
)


class ExpMatCoupling(FactorCouplingBase):
    """
    Generated by a dict-dict mapping out[in] = list-tup-expr
    where list-tup-expr are a means of expressing addition and multiplication as lists and tups.

    lists represent series addition

    tups represent series multiplication, the first term is a raw number coefficient and any further are keys in the source
    vector
    """
    #__slots__ = (
    #    'pkfrom1',
    #    'pkfrom2',
    #    'pkto',
    #    'cplg',
    #    'edges_pkpk_dict',
    #    'edges_NZ_pkset_dict',
    #    'sources_pk_dict',
    #    'sources_NZ_pkset_dict',
    #)

    def __init__(
        self,
        ddlt,
        N_ode = 1,
        order = 2,
    ):
        self.ddlt       = ddlt
        #all edges are generated immediately 
        self.edges_NZ_pkset_dict = {
            (self.pkfrom1, self.pkto) : frozenset(),
        }
        #all edges are generated using the same memoized algorithm
        self.edges_pkpk_dict = {
            (self.pkfrom1, self.pkto) : self.edge_func,
        }

        #TODO make the list of SHG generated powers
        self.sources_pk_dict = {
            self.pkto : self.source_func
        }
        #TODO each SHG generated power requires some juice from its single component
        #but that component may be generated! (So don't require anything)
        self.sources_NZ_pkset_dict = {
            self.pkto : frozenset([]),
        }

    def edge_func(self, sol_vector, sB):
        val = self.cplg * sol_vector.get(self.pkfrom2, 0)
        return val


class NonlinearCrystal(
    bases.OpticalCouplerBase,
    bases.SystemElementBase,
):
    """
    """

    @declarative.dproperty
    def nlg(self, val):
        """
        This is in rtW/(W * mm)

        Should al
        """
        val = self.ooa_params.setdefault('nlg', val)
        return val

    @declarative.dproperty
    def length_mm(self, val = 10):
        """
        in [mm]
        """
        val = self.ooa_params.setdefault('length_mm', val)
        return val

    @declarative.dproperty
    def loss(self, val = 0):
        """
        in W/(W * mm)
        """
        #not yet implemented
        assert(val == 0)
        return val

    def __build__(self):
        super(NonlinearCrystal, self).__build__()
        self.Fr   = ports.OpticalPort(sname = 'Fr' )
        self.Bk   = ports.OpticalPort(sname = 'Bk' )
        return

    @declarative.mproperty
    def ports_optical(self):
        return (
            self.Fr,
            self.Bk,
        )

    def system_setup_ports(self, ports_algorithm):
        tmap = {
            self.Fr: self.Bk,
            self.Bk: self.Fr,
        }

        for port in self.ports_optical:
            for kfrom in ports_algorithm.port_update_get(port.i):
                #gets a passthrough always
                ports_algorithm.port_coupling_needed(tmap[port].o, kfrom)

                okey = kfrom[ports.OpticalFreqKey]
                ckey = kfrom[ports.ClassicalFreqKey]
                qkey = kfrom[ports.QuantumKey]
                barekey = kfrom.without_keys(ports.OpticalFreqKey, ports.ClassicalFreqKey, ports.QuantumKey)

                for kfrom2 in ports_algorithm.port_full_get(port.i):
                    barekey2 = kfrom2.without_keys(ports.OpticalFreqKey, ports.ClassicalFreqKey, ports.QuantumKey)
                    if barekey != barekey2:
                        continue

                    okey2 = kfrom[ports.OpticalFreqKey]
                    ckey2 = kfrom[ports.ClassicalFreqKey]
                    qkey2 = kfrom[ports.QuantumKey]

                    if qkey2 == qkey:
                        #similar quantum keys means sum generation
                        okeyO = okey + okey2
                        ckeyO = ckey + ckey2
                    else:
                        #different keys implies difference generation
                        okeyO = okey - okey2
                        ckeyO = ckey - ckey2

                    if (
                        not self.system.reject_optical_frequency_order(okeyO)
                        and
                        not self.system.reject_classical_frequency_order(ckeyO)
                    ):
                        ports_algorithm.port_coupling_needed(
                            tmap[port].o,
                            barekey | ports.DictKey({
                                ports.OpticalFreqKey   : okeyO,
                                ports.ClassicalFreqKey : ckeyO,
                                ports.QuantumKey       : qkey
                            })
                        )

            for kto in ports_algorithm.port_update_get(port.o):
                #just pass these to the input and it will deal with them
                ports_algorithm.port_coupling_needed(tmap[port].i, kto)
        return

    def system_setup_coupling(self, matrix_algorithm):
        tmap = {
            self.Fr: self.Bk,
            self.Bk: self.Fr,
        }

        for port in self.ports_optical:
            for kfrom in ports_algorithm.port_update_get(port.i):
                #gets a passthrough always
                ports_algorithm.port_coupling_needed(tmap[port].o, kfrom)

                okey = kfrom[ports.OpticalFreqKey]
                ckey = kfrom[ports.ClassicalFreqKey]
                qkey = kfrom[ports.QuantumKey]
                barekey = kfrom.without_keys(ports.OpticalFreqKey, ports.ClassicalFreqKey, ports.QuantumKey)

                for kfrom2 in ports_algorithm.port_full_get(port.i):
                    barekey2 = kfrom2.without_keys(ports.OpticalFreqKey, ports.ClassicalFreqKey, ports.QuantumKey)
                    if barekey != barekey2:
                        continue

                    okey2 = kfrom[ports.OpticalFreqKey]
                    ckey2 = kfrom[ports.ClassicalFreqKey]
                    qkey2 = kfrom[ports.QuantumKey]

                    if qkey2 == qkey:
                        #similar quantum keys means sum generation
                        okeyO = okey + okey2
                        ckeyO = ckey + ckey2
                    else:
                        #different keys implies difference generation
                        okeyO = okey - okey2
                        ckeyO = ckey - ckey2

                    if (
                        not self.system.reject_optical_frequency_order(okeyO)
                        and
                        not self.system.reject_classical_frequency_order(ckeyO)
                    ):
                        ports_algorithm.port_coupling_needed(
                            tmap[port].o,
                            barekey | ports.DictKey({
                                ports.OpticalFreqKey   : okeyO,
                                ports.ClassicalFreqKey : ckeyO,
                                ports.QuantumKey       : qkey
                            })
                        )

            for kto in ports_algorithm.port_update_get(port.o):
                #just pass these to the input and it will deal with them
                ports_algorithm.port_coupling_needed(tmap[port].i, kto)
        for port in self.ports_optical:
            for kfrom in matrix_algorithm.port_set_get(port.i):
                if kfrom[ports.OpticalFreqKey] != okey:
                    continue
                kckey = kfrom[ports.ClassicalFreqKey]
                reflected_SB = 2*ckey - kckey
                #if self.system.reject_classical_frequency_order(reflected_SB):
                #    continue
                if kfrom.contains(ports.LOWER):
                    ktoR = kfrom.replace_keys({ports.ClassicalFreqKey: reflected_SB}, ports.RAISE)
                    phi_cplC = self.symbols.math.exp(2 * -self.symbols.i2pi * self.phi_sqz_deg / 360)
                elif kfrom.contains(ports.RAISE):
                    ktoR = kfrom.replace_keys({ports.ClassicalFreqKey: reflected_SB}, ports.LOWER)
                    phi_cplC = self.symbols.math.exp(2 * self.symbols.i2pi * self.phi_sqz_deg / 360)

                pto = tmap[port]
                cplg1 = self.used_nonlinear_field_gain_1 * self.symbols.math.sqrt(1 - self.used_loss)
                cplg2 = phi_cplC * self.used_nonlinear_field_gain_2 * self.symbols.math.sqrt(1 - self.used_loss)
                matrix_algorithm.port_coupling_insert(
                    port.i,
                    kfrom,
                    pto.o,
                    kfrom,
                    cplg1,
                )
                matrix_algorithm.port_coupling_insert(
                    port.i,
                    kfrom,
                    pto.o,
                    ktoR,
                    cplg2,
                )
        return


